<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Parchment - contextual logging in go | stdout by Nakul</title>
<meta name="keywords" content="">
<meta name="description" content="In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.
This is where parchment comes in — a minimalist wrapper around zerolog that enables logger propagation using Go’s native context.Context.">
<meta name="author" content="">
<link rel="canonical" href="https://nakul.net/posts/parchment/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://nakul.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nakul.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nakul.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nakul.net/apple-touch-icon.png">
<link rel="mask-icon" href="https://nakul.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://nakul.net/posts/parchment/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://nakul.net/posts/parchment/">
  <meta property="og:site_name" content="stdout by Nakul">
  <meta property="og:title" content="Parchment - contextual logging in go">
  <meta property="og:description" content="In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.
This is where parchment comes in — a minimalist wrapper around zerolog that enables logger propagation using Go’s native context.Context.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-08T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-06-08T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Parchment - contextual logging in go">
<meta name="twitter:description" content="In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.
This is where parchment comes in — a minimalist wrapper around zerolog that enables logger propagation using Go’s native context.Context.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nakul.net/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Parchment - contextual logging in go",
      "item": "https://nakul.net/posts/parchment/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Parchment - contextual logging in go",
  "name": "Parchment - contextual logging in go",
  "description": "In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.\nThis is where parchment comes in — a minimalist wrapper around zerolog that enables logger propagation using Go’s native context.Context.\n",
  "keywords": [
    
  ],
  "articleBody": "In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.\nThis is where parchment comes in — a minimalist wrapper around zerolog that enables logger propagation using Go’s native context.Context.\nWhy Pass Loggers via Context? Traditionally, logger instances are passed around explicitly, like so:\nfunc handler(logger zerolog.Logger) { dbCall(logger) } func dbCall(logger zerolog.Logger) { logger.Info().Msg(\"querying db\") } While this works, it leads to bloated function signatures and makes deep call stacks harder to trace. More importantly, you lose the ability to attach structured fields at the entry point (say, a request) and have them persist automatically across the stack.\nInstead, by embedding the logger into a context, you can attach key-value pairs once, and automatically include them in all logs downstream.\nWhat Is Parchment? parchment is a lightweight library that solves this elegantly:\nIt injects a zerolog.Logger into context. It allows adding structured fields to the logger in-place, updating the context in a functional style. It provides convenient helpers to extract the logger and log messages anywhere the context is available. Basic Usage package main import ( \"context\" \"github.com/thenakulchawla/parchment\" ) func main() { ctx := context.Background() ctx = parchment.New(ctx) ctx = parchment.AddToLogger(ctx, []parchment.LoggerField{ {Key: \"request_id\", Value: \"abc-123\"}, {Key: \"user\", Value: \"nakul\"}, }) handle(ctx) } func handle(ctx context.Context) { log := parchment.FromContext(ctx) log.Info().Msg(\"handling request\") } The output will look like:\n{\"level\":\"info\",\"request_id\":\"abc-123\",\"user\":\"nakul\",\"message\":\"handling request\"} Inner Workings parchment defines a context key type internally and stores a zerolog.Logger instance in the context. When calling AddToLogger, the library retrieves the existing logger, appends fields using With(), and returns a new logger injected into a new context.\nTo safely extract and use the logger, it provides functions like:\nFromContext(ctx context.Context) zerolog.Logger: safely retrieves the logger or returns a no-op logger. AddToLogger(ctx, fields): adds multiple fields. Convenience functions like Info(ctx), Error(ctx), Debug(ctx) return corresponding zerolog event writers. This is done in a safe, type-checked way to prevent panics and ensure fallback behavior.\nBenefits Cleaner Function Signatures You no longer have to pass logger as an argument across functions. The context already exists for request-scoped data; adding the logger to it is natural and clean.\nLifecycle-bound Fields With each function having access to the same context, structured fields like request_id, job_name, or retry_count remain consistent and automatically attached to logs.\nBetter Tracing and Observability When logs across a request, job, or event share the same contextual fields, it’s easier to trace them in tools like Loki, Elasticsearch, or even just grep.\nPlug-and-Play with zerolog If you’re already using zerolog, parchment is a non-intrusive addition — just wrap your logger at the entry point and forget about it.\nWhen Should You Use It?\nparchment is ideal when:\nYou’re building microservices and want per-request tracing. You have deep call stacks where passing the logger explicitly is cumbersome. You use zerolog and want a simple way to propagate fields. If you’re building a CLI or small script where global logging suffices, parchment might be overkill. But for larger systems with concurrency, retries, and multiple goroutines — context-based logging is a huge win.\nConclusion Logging is more than just printing messages — it’s about maintaining observability across layers and lifecycles. With parchment, you can structure logs in a way that naturally fits Go’s idioms, especially its use of context.\nGive it a try: github.com/thenakulchawla/parchment\nLet your logs follow your context — not the other way around.\n",
  "wordCount" : "597",
  "inLanguage": "en",
  "datePublished": "2024-06-08T00:00:00Z",
  "dateModified": "2024-06-08T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nakul.net/posts/parchment/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "stdout by Nakul",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nakul.net/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nakul.net/" accesskey="h" title="stdout by Nakul (Alt + H)">stdout by Nakul</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Parchment - contextual logging in go
    </h1>
    <div class="post-meta"><span title='2024-06-08 00:00:00 +0000 UTC'>June 8, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>In many Go projects, structured logging becomes an essential tool for observability. When building microservices or backend APIs, logging with contextual information like request IDs, user IDs, or operation names becomes vital. One challenge, however, is passing logger instances through multiple layers of function calls without cluttering signatures or breaking separation of concerns.</p>
<p>This is where <a href="https://github.com/thenakulchawla/parchment">parchment</a> comes in — a minimalist wrapper around <a href="https://github.com/rs/zerolog">zerolog</a> that enables logger propagation using Go’s native context.Context.</p>
<h3 id="why-pass-loggers-via-context">Why Pass Loggers via Context?<a hidden class="anchor" aria-hidden="true" href="#why-pass-loggers-via-context">#</a></h3>
<p>Traditionally, logger instances are passed around explicitly, like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">logger</span> <span style="color:#a6e22e">zerolog</span>.<span style="color:#a6e22e">Logger</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dbCall</span>(<span style="color:#a6e22e">logger</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dbCall</span>(<span style="color:#a6e22e">logger</span> <span style="color:#a6e22e">zerolog</span>.<span style="color:#a6e22e">Logger</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">logger</span>.<span style="color:#a6e22e">Info</span>().<span style="color:#a6e22e">Msg</span>(<span style="color:#e6db74">&#34;querying db&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>While this works, it leads to bloated function signatures and makes deep call stacks harder to trace. More importantly, you lose the ability to attach structured fields at the entry point (say, a request) and have them persist automatically across the stack.</p>
<p>Instead, by embedding the logger into a context, you can attach key-value pairs once, and automatically include them in all logs downstream.</p>
<h3 id="what-is-parchment">What Is Parchment?<a hidden class="anchor" aria-hidden="true" href="#what-is-parchment">#</a></h3>
<p>parchment is a lightweight library that solves this elegantly:</p>
<ol>
<li>It injects a zerolog.Logger into context.</li>
<li>It allows adding structured fields to the logger in-place, updating the context in a functional style.</li>
<li>It provides convenient helpers to extract the logger and log messages anywhere the context is available.</li>
</ol>
<h3 id="basic-usage">Basic Usage<a hidden class="anchor" aria-hidden="true" href="#basic-usage">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;github.com/thenakulchawla/parchment&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span> = <span style="color:#a6e22e">parchment</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span> = <span style="color:#a6e22e">parchment</span>.<span style="color:#a6e22e">AddToLogger</span>(<span style="color:#a6e22e">ctx</span>, []<span style="color:#a6e22e">parchment</span>.<span style="color:#a6e22e">LoggerField</span>{
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">Key</span>: <span style="color:#e6db74">&#34;request_id&#34;</span>, <span style="color:#a6e22e">Value</span>: <span style="color:#e6db74">&#34;abc-123&#34;</span>},
</span></span><span style="display:flex;"><span>		{<span style="color:#a6e22e">Key</span>: <span style="color:#e6db74">&#34;user&#34;</span>, <span style="color:#a6e22e">Value</span>: <span style="color:#e6db74">&#34;nakul&#34;</span>},
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">parchment</span>.<span style="color:#a6e22e">FromContext</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Info</span>().<span style="color:#a6e22e">Msg</span>(<span style="color:#e6db74">&#34;handling request&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The output will look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;level&#34;</span>:<span style="color:#e6db74">&#34;info&#34;</span>,<span style="color:#f92672">&#34;request_id&#34;</span>:<span style="color:#e6db74">&#34;abc-123&#34;</span>,<span style="color:#f92672">&#34;user&#34;</span>:<span style="color:#e6db74">&#34;nakul&#34;</span>,<span style="color:#f92672">&#34;message&#34;</span>:<span style="color:#e6db74">&#34;handling request&#34;</span>}
</span></span></code></pre></div><h3 id="inner-workings">Inner Workings<a hidden class="anchor" aria-hidden="true" href="#inner-workings">#</a></h3>
<p>parchment defines a context key type internally and stores a zerolog.Logger instance in the context. When calling AddToLogger, the library retrieves the existing logger, appends fields using With(), and returns a new logger injected into a new context.</p>
<p>To safely extract and use the logger, it provides functions like:</p>
<ul>
<li>FromContext(ctx context.Context) zerolog.Logger: safely retrieves the logger or returns a no-op logger.</li>
<li>AddToLogger(ctx, fields): adds multiple fields.</li>
<li>Convenience functions like Info(ctx), Error(ctx), Debug(ctx) return corresponding zerolog event writers.</li>
</ul>
<p>This is done in a safe, type-checked way to prevent panics and ensure fallback behavior.</p>
<h3 id="benefits">Benefits<a hidden class="anchor" aria-hidden="true" href="#benefits">#</a></h3>
<ol>
<li>Cleaner Function Signatures</li>
</ol>
<p>You no longer have to pass logger as an argument across functions. The context already exists for request-scoped data; adding the logger to it is natural and clean.</p>
<ol start="2">
<li>Lifecycle-bound Fields</li>
</ol>
<p>With each function having access to the same context, structured fields like request_id, job_name, or retry_count remain consistent and automatically attached to logs.</p>
<ol start="3">
<li>Better Tracing and Observability</li>
</ol>
<p>When logs across a request, job, or event share the same contextual fields, it’s easier to trace them in tools like Loki, Elasticsearch, or even just grep.</p>
<ol start="4">
<li>Plug-and-Play with zerolog</li>
</ol>
<p>If you’re already using zerolog, parchment is a non-intrusive addition — just wrap your logger at the entry point and forget about it.</p>
<p>When Should You Use It?</p>
<p>parchment is ideal when:</p>
<ul>
<li>You’re building microservices and want per-request tracing.</li>
<li>You have deep call stacks where passing the logger explicitly is cumbersome.</li>
<li>You use zerolog and want a simple way to propagate fields.</li>
</ul>
<p>If you’re building a CLI or small script where global logging suffices, parchment might be overkill. But for larger systems with concurrency, retries, and multiple goroutines — context-based logging is a huge win.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Logging is more than just printing messages — it’s about maintaining observability across layers and lifecycles. With parchment, you can structure logs in a way that naturally fits Go’s idioms, especially its use of context.</p>
<p>Give it a try:
<a href="https://github.com/thenakulchawla/parchment">github.com/thenakulchawla/parchment</a></p>
<p>Let your logs follow your context — not the other way around.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://nakul.net/">stdout by Nakul</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
